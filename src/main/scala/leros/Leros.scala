/*
 * Leros, a Tiny Microprocessor
 *
 * Author: Martin Schoeberl (martin@jopdesign.com)
 */

package leros

import leros.util._

import chisel3._
import chisel3.util._

// should go into it's own file and used by HW, simulator, and Assembler (compiler as well?)
/*
+--------+----------+
|00000--i| nop      |
|000010-i| add      |
|000011-i| sub      |
|00010--i| shr      |
|00011--i| unused   |
|0010000i| load     |
|0010001i| and      |
|0010010i| or       |
|0010011i| xor      |
|00101--i| loadh    |
|00110--i| store    |
|001110-i| out      |
|000001-i| in       |
|01000---| jal      |
|01001000| br       |
|01001001| brz      |
|01001010| brnz     |
|01001011| brp      |
|01001100| brn      |
|01010---| ldaddr   |
|01100---| load ind |
|01110---| store ind|
+--------+----------+
 */

// Shall we keep this immediate bit in one position and do more complex decoding?
// Or would a simple table just do it?
// If we simple enumerate the 27 instructions, we would just decode 5 bits, freeing another 3 bits
// We could use this to get larger constants in, e.g. up to 15 bits. Useful?
object Constants {
  val NOP = 0x00 // useless
  val ADD = 0x08
  val ADDI = 0x09
  val SUB = 0x0c
  val SUBI = 0x0d
  val SHR = 0x10
  val LD = 0x20
  val LDI = 0x21
  val AND = 0x22
  val ANDI = 0x23
  val OR = 0x24
  val ORI = 0x25
  val XOR = 0x26
  val XORI = 0x27
  val LOADH = 0x29 // only immediate useful
  val ST = 0x30
  val OUT = 0x39 // is IN/OUT immediate only?
  val IN = 0x05
  val JAL = 0x40
  val BR = 0x48
  val BRZ = 0x49
  val BRNZ = 0x4a
  val BRP = 0x4b
  val BRN = 0x4c
  val LDADDR = 0x50
  val LDIND = 0x60
  val STIND = 0x70
  val SCALL = 0xff // 0 is simulator exit
}

class Debug extends Bundle {
  val acc = Output(UInt())
  val pc = Output(UInt())
  val instr = Output(UInt())
}

class DecodeOut extends Bundle {
  val add = Bool()
}

class Decode() extends Module {
  val io = IO(new Bundle {
    val din = Input(UInt(8.W))
    val dout = Output(new DecodeOut)
  })
}

/**
  * Instruction memory.
  * Contains the register for using the on-chip ROM.
  * Uses Chisel synchronous reset to also execute the first instruction.
  */
class InstrMem(memSize: Int) extends Module {
  val io = IO(new Bundle {
    val addr = Input(UInt(memSize.W))
    val instr = Output(UInt(16.W))
  })
  val progMem = VecInit(Assembler.getProgram().map(_.asUInt(16.W)))
  val memReg = RegInit(0.U(memSize.W))
  memReg := io.addr
  io.instr := progMem(memReg)
}

/**
  * Leros top level
  */
class Leros(size: Int, memSize: Int) extends Module {
  val io = IO(new Bundle {
    val dout = Output(UInt(32.W))
    val dbg = new Debug
  })

  // The main architectural state
  val accuReg = RegInit(0.U(size.W))
  val pcReg = RegInit(0.U(memSize.W))
  val addrReg = RegInit(0.U(memSize.W))


  val nop :: add :: sub :: and :: or :: xor :: ld :: Nil = Enum(7)

  // do we need register duplication, using the PC + x as input, to get a memory for this?
  // The synchronous reset, generated by Chisel, should be fine.
  val pcNext = pcReg + 1.U
  pcReg := pcNext

  val mem = Module(new InstrMem(memSize))
  mem.io.addr := pcNext
  val instr = mem.io.instr

  // Maybe decoding and sign extension into fetch
  // Play around with the pipeline registers when (1) more complete ALU and (2) longer programs (= block RAM)
  val opcode = instr(15, 8)
  val operand = Wire(SInt(size.W))
  operand := instr(7, 0).asSInt // sign extension
  // TODO: only sign extend when arithmetic
  val opReg = RegNext(operand)

  // Decode

  val funcReg = RegInit(nop)
  when(opcode === 0x09.U) {
    funcReg := add
  }.elsewhen(opcode === 0x0d.U) {
    funcReg := sub
  }

  val op = opReg.asUInt
  switch(funcReg) {
    is(add) {
      accuReg := accuReg + op
    }
    is(sub) {
      accuReg := accuReg - op
    }
    is(and) {
      accuReg := accuReg & op
    }
    is(or) {
      accuReg := accuReg | op
    }
    is(xor) {
      accuReg := accuReg ^ op
    }
    is(ld) {
      accuReg := op
    }
  }

  val exit = RegInit(false.B)

  println("Generating Leros")
  io.dout := 42.U

  io.dbg.acc := accuReg
  io.dbg.pc := pcReg
  io.dbg.instr := instr
}

object Leros extends App {
  Driver.execute(Array("--target-dir", "generated"), () => new Leros(32, 10))
}
